<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>用MyBatis查询得到的数据量比在数据库得到的数据少</title>
    <link href="/2020/06/29/%E7%94%A8MyBatis%E6%9F%A5%E8%AF%A2%E5%BE%97%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F%E6%AF%94%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BE%97%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B0%91/"/>
    <url>/2020/06/29/%E7%94%A8MyBatis%E6%9F%A5%E8%AF%A2%E5%BE%97%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F%E6%AF%94%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BE%97%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h1><p>如果查询的数据中缺失唯一标识的字段的话，mybatis会过滤掉那些它觉得重复了的数据。</p><p>#解决方案：</p><p>在查询结果中增加主键id。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 发送邮件，附件名乱码问题</title>
    <link href="/2020/06/23/Java-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%EF%BC%8C%E9%99%84%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/23/Java-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%EF%BC%8C%E9%99%84%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#问题描述</p><p>在使用 apache commons mail 工具发邮件时，发现邮件中的附件名称有时候会出现乱码。</p><p>查阅资料得到的解决方案是通过javax.mail.internet.MimeUtility.encodeText()就可解决这个附件乱码的问题。但是看了源码已经使用了 MimeUtility.encodeText()。源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> MultiPartEmail <span class="hljs-title">attach</span><span class="hljs-params">(DataSource ds, String name, String description, String disposition)</span> <span class="hljs-keyword">throws</span> EmailException </span>&#123;    <span class="hljs-keyword">if</span> (EmailUtils.isEmpty(name)) &#123;      name = ds.getName();    &#125;    BodyPart bodyPart = <span class="hljs-keyword">this</span>.createBodyPart();    <span class="hljs-keyword">try</span> &#123;      bodyPart.setDisposition(disposition);      bodyPart.setFileName(MimeUtility.encodeText(name));      bodyPart.setDescription(description);      bodyPart.setDataHandler(<span class="hljs-keyword">new</span> DataHandler(ds));      <span class="hljs-keyword">this</span>.getContainer().addBodyPart(bodyPart);    &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException var7) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmailException(var7);    &#125; <span class="hljs-keyword">catch</span> (MessagingException var8) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmailException(var8);    &#125;    <span class="hljs-keyword">this</span>.setBoolHasAttachments(<span class="hljs-keyword">true</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;  &#125;</code></pre><p>继续查阅资料发现对文件进行编码时超出长度会自动添加通过”/r”,”/n”符号来分割字符串。MimeUtility.encodeText可能通过”_”进行连接。因此只要替换了”/r”,”/n”即可。博主给出的解决方案如下：</p><pre><code class="hljs java">String filename = MimeUtility.encodeText(f.getName());filename = filename.replaceAll(<span class="hljs-string">"\r"</span>, <span class="hljs-string">""</span>).replaceAll(<span class="hljs-string">"\n"</span>, <span class="hljs-string">""</span>);fileBodyPart.setFileName(filename);</code></pre><p>由于我的项目是使用了apache commons mail 工具，去改源码太麻烦。</p><p>最后查到资料可以通过设置环境变量不去截断过长的字符串。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>文件前面添加如下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;            System.setProperty(<span class="hljs-string">"mail.mime.splitlongparameters"</span>,<span class="hljs-string">"false"</span>);            System.setProperty(<span class="hljs-string">"mail.mime.charset"</span>,<span class="hljs-string">"UTF-8"</span>);        &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring后端项目用Date接收时间参数的问题</title>
    <link href="/2020/06/12/Spring%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%94%A8Date%E6%8E%A5%E6%94%B6%E6%97%B6%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/12/Spring%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%94%A8Date%E6%8E%A5%E6%94%B6%E6%97%B6%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在Spring后端用对象接受参数，如果POJO中包含Date类型的数据，会出去如下问题：</p><ul><li>前端传过来的格式为”yyyy-MM-dd”, 则接受到的时间会多8小时。</li><li>前端传过来的格式为”yyyy-MM-dd HH:mm:ss”， 则会报非法参数异常。</li></ul><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><ul><li>spring转json的默认实现jackson中会根据时区去转换时间，而jackson的默认时区跟 国内应该是相差8小时，所以再时间换算上自动加上了8小时。</li><li>加上时分秒后无法转化为Date类型的数据。</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>  添加@DateTimeFormat注解</p>  <pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateVO</span> </span>&#123;  <span class="hljs-meta">@DateTimeFormat</span>(pattern=<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>)  <span class="hljs-keyword">private</span> Date date;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis 缓存造成的坑</title>
    <link href="/2020/06/11/Mybatis-%E7%BC%93%E5%AD%98%E9%80%A0%E6%88%90%E7%9A%84%E5%9D%91/"/>
    <url>/2020/06/11/Mybatis-%E7%BC%93%E5%AD%98%E9%80%A0%E6%88%90%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>在写代码的过程中发现：在一个事务中，如果同样的查询SQL执行了两次，并且这两次之间没有执行update。由于mybatis缓存的存在，第二次select的时候讲不会去查询数据库，而是直接返回第一次查询结果对象。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>测试代码1：</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;  OrderInfoDO orderInfoDO = orderInfoMapper.selectByOrderId(<span class="hljs-number">1000000</span>);  OrderInfoDO orderInfoDO2 = orderInfoMapper.selectByOrderId(<span class="hljs-number">1000000</span>);&#125;</code></pre><p>观察控制台，select order_info的sql只执行了一次。</p><ul><li>测试代码2：</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;  OrderInfoDO orderInfoDO = orderInfoMapper.selectByOrderId(<span class="hljs-number">1000000</span>);  orderInfoMapper.update(orderInfoDO);  OrderInfoDO orderInfoDO2 = orderInfoMapper.selectByOrderId(<span class="hljs-number">1000000</span>);&#125;</code></pre><p>观察控制台，select order_info的sql只执行了两次。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis association嵌套select语句的性能</title>
    <link href="/2020/06/11/Mybatis-association%E5%B5%8C%E5%A5%97select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <url>/2020/06/11/Mybatis-association%E5%B5%8C%E5%A5%97select%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>嵌套select语句会带来n+1问题，降低程序的性能，但并有些情况下恰恰相反。由于Mybatis 缓存的存在，如果嵌套查询的数据量重复比例很大，反而会提高效率。</p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>通过嵌套sql语句和inner join的方式分别查询多个订单，并且关联查询货主和仓库。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>两种方式分别查询3次，取花费时间平均值。</p><table><thead><tr><th align="left">查询数据量/平均执行时间</th><th align="left">嵌套sql语句（ms）</th><th>inner join方法（ms）</th></tr></thead><tbody><tr><td align="left">1000</td><td align="left">(646+712+648)/3=668.7</td><td>(706+745+829)/3=760</td></tr><tr><td align="left">10000</td><td align="left">(2120+2257+2023)/3=2133.3</td><td>(2920+2543+2999)/3=2820.7</td></tr><tr><td align="left">100000</td><td align="left">(12152+12649+11994)/3=12265</td><td>(14467+13981+15003)/3=14483.7</td></tr></tbody></table><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>由于嵌套查询的货主和仓库重复率很高，mybatis会直接从缓存中获取货主和仓库数据而不需要查询数据库（观察了嵌套sql语句查1000条数据时控制台输出的日志，查询同一货主的sql只执行了一次）。这种情况下嵌套select语句的方式性能反而会得到提升。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 8 语法 demo</title>
    <link href="/2020/06/11/Java-8-stream-demo/"/>
    <url>/2020/06/11/Java-8-stream-demo/</url>
    
    <content type="html"><![CDATA[<h3 id="1-list-to-list，取-list-中对象的某个属性，组成一个新的-list"><a href="#1-list-to-list，取-list-中对象的某个属性，组成一个新的-list" class="headerlink" title="1. list to list，取 list 中对象的某个属性，组成一个新的 list"></a>1. list to list，取 list 中对象的某个属性，组成一个新的 list</h3><pre><code class="hljs java">List&lt;Integer&gt; orderIds = orderInfoToReserveList.stream()  .map(OrderInfoDO::getOrderId)  .collect(Collectors.toList());</code></pre><h3 id="2-list-to-map，value-为对象的-list"><a href="#2-list-to-map，value-为对象的-list" class="headerlink" title="2. list to map，value 为对象的 list"></a>2. list to map，value 为对象的 list</h3><pre><code class="hljs java">Map&lt;String, List&lt;InventoryItemDO&gt;&gt; inventoryItemMap = inventoryItemDoList.stream()  .collect(Collectors           .groupingBy(ii -&gt; ii.getStatus().name() + <span class="hljs-string">"-"</span> + ii.getProductId());</code></pre><h3 id="3-list-to-map，value-为-list-中的对象本身"><a href="#3-list-to-map，value-为-list-中的对象本身" class="headerlink" title="3. list to map，value 为 list 中的对象本身"></a>3. list to map，value 为 list 中的对象本身</h3><pre><code class="hljs java">Map&lt;Integer, InventorySummaryDO&gt; inventorySummaryDoMap = inventorySummaryDoList.stream()    .collect(Collectors             .toMap(InventorySummaryDO::getInventorySummaryId, Function.identity()));</code></pre><h3 id="4-list-to-map，value-为-list-中对象某个属性的和"><a href="#4-list-to-map，value-为-list-中对象某个属性的和" class="headerlink" title="4. list to map，value 为 list 中对象某个属性的和"></a>4. list to map，value 为 list 中对象某个属性的和</h3><pre><code class="hljs java">Map&lt;String, Integer&gt; reserveSumMap = reserveOrderGoodsDtoList.stream()        .collect(Collectors                 .groupingBy(reserveOrderGoodsDTO -&gt; reserveOrderGoodsDTO.getStatusId().name() + <span class="hljs-string">"-"</span> + reserveOrderGoodsDTO.getProductId(), Collectors.summingInt(ReserveOrderGoodsDTO::getGoodsNumber)));</code></pre><h3 id="5-list-to-map，value-为-list-中对象某个属性组成的-list"><a href="#5-list-to-map，value-为-list-中对象某个属性组成的-list" class="headerlink" title="5. list to map，value 为 list 中对象某个属性组成的 list"></a>5. list to map，value 为 list 中对象某个属性组成的 list</h3><pre><code class="hljs java">Map&lt;Integer, List&lt;String&gt;&gt; productSerialMap = inventorySerialDoList.stream()    .collect(Collectors             .groupingBy(InventorySerialDO::getProductId, Collectors.mapping(InventorySerialDO::getSerialNumber, Collectors.toList())));</code></pre><h3 id="6-遍历map"><a href="#6-遍历map" class="headerlink" title="6. 遍历map"></a>6. 遍历map</h3><pre><code class="hljs java">updateProductLocationMap.forEach((k,v) -&gt; productLocationMapper.batchUpdateValidityStatus(k, v));</code></pre><h3 id="7-对-list-中对象的某个属性求和"><a href="#7-对-list-中对象的某个属性求和" class="headerlink" title="7. 对 list 中对象的某个属性求和"></a>7. 对 list 中对象的某个属性求和</h3><pre><code class="hljs java">Integer sum = inventoryItemDoList.stream()  .mapToInt(InventoryItemDO::getAvailableToReserved)  .sum();</code></pre><h3 id="8-合并-list"><a href="#8-合并-list" class="headerlink" title="8. 合并 list"></a>8. 合并 list</h3><pre><code class="hljs java"><span class="hljs-comment">/*交集*/</span><span class="hljs-comment">/*[AClass(id=1, name=zhuoli1, description=haha1)]*/</span>List&lt;AClass&gt; intersectResult = aClassList1.stream().filter(aClassList2::contains).collect(Collectors.toList()); <span class="hljs-comment">/*并集*/</span> List&lt;Integer&gt; productLocationIds = taskCountDoList.stream()    .map(TaskCountDO::getPlIds)    .flatMap(Collection::stream)    .distinct()    .collect(Collectors.toList()); <span class="hljs-comment">/*差集*/</span><span class="hljs-comment">/*[AClass(id=2, name=zhuoli2, description=haha2), AClass(id=3, name=zhuoli3, description=haha3)]*/</span>List&lt;AClass&gt; differenceResult = aClassList1.stream().filter(x -&gt; !aClassList2.contains(x)).collect(Collectors.toList());</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化实战（一）</title>
    <link href="/2020/06/11/SQL%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/"/>
    <url>/2020/06/11/SQL%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="实战1："><a href="#实战1：" class="headerlink" title="实战1："></a>实战1：</h1><ul><li>SQL 功能：校验 inventory_summary.available_to_reserved 与相关的 inventory_item 的 available_to_reserved 之和是否存在差异。</li><li>优化前 SQL：</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> product_id productId, warehouse_id warehouseId, <span class="hljs-keyword">status</span>, <span class="hljs-keyword">sum</span>(stock_quantity) <span class="hljs-keyword">result</span>    <span class="hljs-keyword">FROM</span>    (<span class="hljs-keyword">SELECT</span> ii.product_id, ii.warehouse_id, ii.status    , <span class="hljs-keyword">SUM</span>(quantity) * <span class="hljs-number">-1</span> <span class="hljs-keyword">AS</span> stock_quantity, ii.inventory_summary_id    <span class="hljs-keyword">FROM</span> wms.inventory_item ii    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ii.product_id, ii.warehouse_id, ii.status    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>    <span class="hljs-keyword">SELECT</span> ism.product_id, ism.warehouse_id, ism.status_id <span class="hljs-keyword">AS</span> <span class="hljs-keyword">status</span>, ism.stock_quantity,ism.inventory_summary_id    <span class="hljs-keyword">FROM</span> wms.inventory_summary ism    ) a    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> inventory_summary_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">result</span> != <span class="hljs-number">0</span>    <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">100000</span>;</code></pre><ul><li>优化前耗时：0.85 s</li><li>优化前explain：</li></ul><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">PRIMARY</td><td align="left"><derived2></td><td align="left">ALL</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">429616</td><td align="left">Using temporary; Using filesort</td></tr><tr><td align="left">2</td><td align="left">DERIVED</td><td align="left">ii</td><td align="left">ALL</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">417195</td><td align="left">Using temporary; Using filesort</td></tr><tr><td align="left">3</td><td align="left">UNION</td><td align="left">ism</td><td align="left">ALL</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">12421</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">UNION RESULT</td><td align="left">&lt;union2,3&gt;</td><td align="left">ALL</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">Using temporary</td></tr></tbody></table><ul><li>优化后SQL：</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> product_id productId, warehouse_id warehouseId, <span class="hljs-keyword">status</span>, <span class="hljs-keyword">sum</span>(stock_quantity) <span class="hljs-keyword">result</span>    <span class="hljs-keyword">FROM</span>    (<span class="hljs-keyword">SELECT</span> ii.product_id, ii.warehouse_id, ii.status    , <span class="hljs-keyword">SUM</span>(quantity) * <span class="hljs-number">-1</span> <span class="hljs-keyword">AS</span> stock_quantity, ii.inventory_summary_id    <span class="hljs-keyword">FROM</span> wms.inventory_item ii    <span class="hljs-keyword">WHERE</span> ii.quantity &gt; <span class="hljs-number">0</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ii.product_id, ii.warehouse_id, ii.status    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>    <span class="hljs-keyword">SELECT</span> ism.product_id, ism.warehouse_id, ism.status_id <span class="hljs-keyword">AS</span> <span class="hljs-keyword">status</span>, ism.stock_quantity,ism.inventory_summary_id    <span class="hljs-keyword">FROM</span> wms.inventory_summary ism    <span class="hljs-keyword">WHERE</span> ism.stock_quantity &gt; <span class="hljs-number">0</span>    ) a    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> inventory_summary_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">result</span> != <span class="hljs-number">0</span>    <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">100000</span>;</code></pre><ul><li>优化前耗时：0.85 s</li><li>优化后explain：0.13 s</li></ul><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">PRIMARY</td><td align="left"><derived2></td><td align="left">ALL</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">57129</td><td align="left">Using temporary; Using filesort</td></tr><tr><td align="left">2</td><td align="left">DERIVED</td><td align="left">ii</td><td align="left">range</td><td align="left">quantity</td><td align="left">quantity</td><td align="left">4</td><td align="left"></td><td align="left">44708</td><td align="left">Using index condition; Using temporary; Using filesort</td></tr><tr><td align="left">3</td><td align="left">UNION</td><td align="left">ism</td><td align="left">ALL</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">12421</td><td align="left">Using where</td></tr><tr><td align="left"></td><td align="left">UNION RESULT</td><td align="left">&lt;union2,3&gt;</td><td align="left">ALL</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">Using temporary</td></tr></tbody></table><ul><li>优化思路：由于是对 inventory_item.quantity 求和，所以可以排除掉 quantity 不为 0 的数据。加上 quantity &gt; 0 的条件后，使用了 quantity 索引。</li></ul><h1 id="实战2"><a href="#实战2" class="headerlink" title="实战2:"></a>实战2:</h1><ul><li>优化前SQL：</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> (is_reserved = <span class="hljs-string">'N'</span><span class="hljs-keyword">AND</span> order_status = <span class="hljs-string">'ACCEPT'</span><span class="hljs-keyword">AND</span> order_type = <span class="hljs-string">'SALE'</span><span class="hljs-keyword">AND</span> customer_id = <span class="hljs-number">63</span><span class="hljs-keyword">AND</span> created_time &gt;= <span class="hljs-string">'2020-04-26 16:56:10.035'</span>)<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10000</span>;</code></pre><ul><li>优化前耗时：1.65 s</li><li>优化前explain：</li></ul><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">order_info</td><td align="left">ref</td><td align="left">order_status,customer_id,order_type,created_time,multi_order_info_key2</td><td align="left">customer_id</td><td align="left">4</td><td align="left">const</td><td align="left">1</td><td align="left">Using where</td></tr></tbody></table><ul><li>优化后SQL：</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">force</span> <span class="hljs-keyword">index</span>(multi_order_info_key2)<span class="hljs-keyword">WHERE</span> (is_reserved = <span class="hljs-string">'N'</span><span class="hljs-keyword">AND</span> order_status = <span class="hljs-string">'ACCEPT'</span><span class="hljs-keyword">AND</span> order_type = <span class="hljs-string">'SALE'</span><span class="hljs-keyword">AND</span> customer_id = <span class="hljs-number">63</span><span class="hljs-keyword">AND</span> created_time &gt;= <span class="hljs-string">'2020-04-26 16:56:10.035'</span>)<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10000</span>;<span class="hljs-comment">#使用的索引：KEY `multi_order_info_key2` (`created_time`,`physical_warehouse_id`,`order_type`,`is_reserved`,`customer_id`,`order_status`)</span></code></pre><ul><li>优化后耗时：0.54 s</li><li>优化后explain：</li></ul><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">order_info</td><td align="left">range</td><td align="left">multi_order_info_key2</td><td align="left">multi_order_info_key2</td><td align="left">6</td><td align="left"></td><td align="left">4445240</td><td align="left">Using index condition</td></tr></tbody></table><ul><li>优化思路：强制使用联合索引。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis association的嵌套select语句，某个参数不是数据表中的字段</title>
    <link href="/2020/06/11/Mybatis-association%E7%9A%84%E5%A4%9A%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/06/11/Mybatis-association%E7%9A%84%E5%A4%9A%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h1><p>在使用Mysql association嵌套select语句时，遇到一个场景：select sql 中有两个参数，其中一个参数并不是数据表中一个字段。</p><p>需求：在查询InventoryImprove的时候能够关联查询ProductLocation。</p><p>BaseResultMap：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.leqee.wms.server.dao.meta.inventoryimprove.InventoryImproveDetailDO"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"inventory_improve_id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"inventoryImproveId"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"pl_id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"plId"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"status"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"improve_num"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"improveNum"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"related_pl_id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"relatedPlId"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"created_time"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"DATE"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createdTime"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"last_updated_time"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"DATE"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"lastUpdatedTime"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"productLocationDO"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"com.leqee.wms.server.dao.meta.productlocation.ProductLocationDO"</span></span><span class="hljs-tag">               <span class="hljs-attr">column</span>=<span class="hljs-string">"pl_id"</span></span><span class="hljs-tag">               <span class="hljs-attr">select</span>=<span class="hljs-string">"com.leqee.wms.server.dao.mapper.productlocation.ProductLocationMapper.selectById"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre><p>ProductLocationMapper.java 的 selectById方法：</p><pre><code class="hljs java"><span class="hljs-function">ProductLocationDO <span class="hljs-title">selectById</span><span class="hljs-params">(@Param(<span class="hljs-string">"plId"</span>)</span> Integer plId, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"forUpdate"</span>)</span> Boolean forUpdate)</span>;</code></pre><p>ProductLocationMapper.xml 的 selectById方法：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectById"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"java.lang.Integer"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span>&gt;</span>  select  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span>/&gt;</span>  from product_location  where pl.pl_id = #&#123;plId,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"forUpdate"</span>&gt;</span>    for update  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><p>本以为这样是没有问题的，因为 ProductLocationMapper.selectById 第二个参数是Boolean类型，不指定值则值为Null，方法可以正常调用。但是在执行InventoryImprove的selectByPrimaryKey方法时报错如下：</p><pre><code class="hljs stylus">org<span class="hljs-selector-class">.mybatis</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.MyBatisSystemException</span>: nested exception is org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.ibatis</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.ReflectionException</span>: There is no getter <span class="hljs-keyword">for</span> property named <span class="hljs-string">'forUpdate'</span> <span class="hljs-keyword">in</span> <span class="hljs-string">'class java.lang.Integer'</span></code></pre><p>forUpdate为非键值对的变量时，无法获得对应变量的get方法。于是尝试association多参数形式：</p><pre><code class="hljs ini"><span class="hljs-attr">column</span>=<span class="hljs-string">"&#123;plId=pl_id&#125;"</span></code></pre><p>依然报错：</p><pre><code class="hljs css"><span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.mybatis</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.MyBatisSystemException</span>: <span class="hljs-selector-tag">nested</span> <span class="hljs-selector-tag">exception</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.ibatis</span><span class="hljs-selector-class">.reflection</span><span class="hljs-selector-class">.ReflectionException</span>: <span class="hljs-selector-tag">Error</span> <span class="hljs-selector-tag">instantiating</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Integer</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">invalid</span> <span class="hljs-selector-tag">types</span> () <span class="hljs-selector-tag">or</span> <span class="hljs-selector-tag">values</span> (). <span class="hljs-selector-tag">Cause</span>: <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NoSuchMethodException</span>: <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Integer</span>.&lt;<span class="hljs-selector-tag">init</span>&gt;()</code></pre><p>问题出现在 ProductLocationMapper.selectById方法上，parameterType=”java.lang.Integer”指定了参数类型为Integer。查看官方文档：</p><pre><code class="hljs bash">parameterType将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（<span class="hljs-built_in">unset</span>）。</code></pre><p>确定去掉parameterType=”java.lang.Integer”没有风险，然后再次执行，成功。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>正确的xml代码：</p><p>BaseResultMap：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"BaseResultMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.leqee.wms.server.dao.meta.inventoryimprove.InventoryImproveDetailDO"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"inventory_improve_id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"BIGINT"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"inventoryImproveId"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"pl_id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"plId"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"status"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"VARCHAR"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"status"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"improve_num"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"improveNum"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"related_pl_id"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"INTEGER"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"relatedPlId"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"created_time"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"DATE"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"createdTime"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"last_updated_time"</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">"DATE"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"lastUpdatedTime"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"productLocationDO"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"com.leqee.wms.server.dao.meta.productlocation.ProductLocationDO"</span></span><span class="hljs-tag">               <span class="hljs-attr">column</span>=<span class="hljs-string">"pl_id"</span></span><span class="hljs-tag">               <span class="hljs-attr">select</span>=<span class="hljs-string">"com.leqee.wms.server.dao.mapper.productlocation.ProductLocationMapper.selectById"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre><p>ProductLocationMapper.xml 的 selectById方法：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectById"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span>&gt;</span>  select  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"Base_Column_List"</span>/&gt;</span>  from product_location  where pl.pl_id = #&#123;plId,jdbcType=INTEGER&#125;  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"forUpdate"</span>&gt;</span>    for update  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次 IntelliJ IDEA 项目启动非常慢的坑</title>
    <link href="/2020/06/02/%E8%AE%B0%E4%B8%80%E6%AC%A1-IntelliJ-IDEA-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E9%9D%9E%E5%B8%B8%E6%85%A2%E7%9A%84%E5%9D%91/"/>
    <url>/2020/06/02/%E8%AE%B0%E4%B8%80%E6%AC%A1-IntelliJ-IDEA-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E9%9D%9E%E5%B8%B8%E6%85%A2%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>某次在使用 IntelliJ IDEA Debug 模式启动项目的时候，经过很久（半小时以上）也没有启动成功。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>后来发现是由于在方法签名上打了断点导致的。在这种情况下启动项目会提示：Method breakpoints may dramatically slow down debugging。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>去掉打在方法签名上的断点后，项目又能正常启动了。本以为只是会稍微慢点就没在意，没想到慢的离谱。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IntelliJ IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/31/hello-world/"/>
    <url>/2020/05/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
